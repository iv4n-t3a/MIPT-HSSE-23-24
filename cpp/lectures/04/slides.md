---
marp: true
theme: gaia
footer: 'Программирование на языке C++. Гагаринов Даниил. ВШПИ МФТИ 2023'
paginate: true

---
<style>
{
    font-size: 30px
}
</style>

# Лекция 4

---

## 3.9 Конструкторы и деструкторы. Ключевое слово explicit. Делигирующие конструкторы

7. Конструктор копирования
8. Ключевое слово explicit
9. Делигирующие конструкторы
10. Ключевые слова default и delete.
11. Агрегатная инициализация структур
12. Ключевое слово friend
13. Константные методы
14. Статические поля и методы


---
<!-- header: "3.9 Конструкторы и деструкторы. Ключевое слово explicit. Делигирующие конструкторы"-->

### 3.9.7 Конструктор копирования

***Def*** Конструктор копирования позволяет создать новый объект из существующего

```c++
T first;
T second = first; // конструктор копирования
```

***Note*** Это вызов именно конструктора копирования, а не оператора присваивания

***Note*** Конструктор копирования генерируется по умолчанию (копирует каждое поле)

---
Чаще всего нам нужен кастомный конструктор копирования

```c++
class Vector {
public:
  Vector(size_t size, int value = 0): size_(size) {
    arr_ = new int[size_];
    for (int i = 0; i < size; ++i) {
      arr_[i] = value;
    }
  }

  ~Vector() {
    delete[] arr_;
  }
private:
  int* arr_ = nullptr;
  size_t size_ = 0;
}
```

С дефолтным конструктором копирования будет double free!

---

```c++
class Vector {
public:
  Vector(size_t size, int value = 0): size_(size) {
    arr_ = new int[size_];
    for (int i = 0; i < size; ++i) {
      arr_[i] = value;
    }
  }

  Vector(const Vector& other): arr_(new int[other.size_]), size_(other.size_) {
    memcpy(arr_, other.arr_, size_); // deep copy
  }

  ~Vector() {
    delete[] arr_;
  }
private:
  int* arr_ = nullptr;
  size_t size_ = 0;
}
```

---

### 3.9.8 Ключевое слово explicit

```c++
class Vector {
public:
  Vector(size_t size, int value = 0): size_(size), arr_(new int[size_]) {
    for (int i = 0; i < size; ++i) {
      arr_[i] = value;
    }
  }

  ~Vector() { delete[] arr_; }
private:
  size_t size_ = 0;
  int* arr_ = nullptr;
}

int main() {
    Vector v = 10; // хотим запретить такой неявный каст
    v = 2; // хотим запретить такой неявный каст
}
```

---

Для запрета неявного каста служит ключевое слово explicit

```c++
class Vector {
public:
  explicit Vector(size_t size, int value = 0): ...
}
```

Его стоит использовать с конструкторами которые можно вызвать от одного параметра. Это слово запрещает неявный каст.

---

### 3.9.9 Делигирующие конструкторы

В конструкторах часто повторяются одни и те же действия. Хочется уметь вызывать один конструктор из другого, но:

```c++
struct S {
  S(int a) {...}

  S(int a, size_t c) {
    S(a); // Неверно
  }
};
```

Так мы просто создадим еще один объект, а это не то что нам нужно.

---

```c++
struct S {
  S(int a) {
    ...
  }

  S(int a, size_t c): S(a) {
  }
};
```

***Note*** списками инициализации пользоваться не получится

---

### 3.9.10 Ключевые слова default и delete.

Можно явно попросить компилятор сгенерировать метод  если он его умеет генерировать (конструктор по умолчанию, конструктор копирования, оператор присваивания, деструктор и тд).

```c++
struct S {
  S(int a) {...}
  S() = default;
}
```
---
Можно запретить компилятору генерировать метод

```c++
struct S {
  S(const S&) = delete;
}
```
---

### 3.9.11. Агрегатная инициализация структур

```c++
struct S {
  int a;
  int b;
  double c;
  std::string aaa;
}

int main() {
  S s{1, 2, 3.14, "aaaa"};
}
```

---

### 3.9.12. Ключевое слово friend

```c++
class C {
  int a = 0;
  friend void foo(int);
  friend class D;
}

void foo(int b) {
  C c;
  std::cout << c.a + b; // c.a это OK
}

class D {};
```

***Note*** Если A друг B, но это не значит что B друг A
***Note*** Если A друг B и B друг C, то это не значит что A друг C

---

### 3.9.13 Константные методы

***Def*** Константный метод это метод который можно вызвать у констаного объекта (у неконстантного тоже можно)

***Note*** В константном методе нельзя менять поля объекта

***Note*** В константном методе нельзя вызывать не константные методы

---

```c++
struct S {
    void Test() { std::cout << 0;}
    void Bar() { std::cout << 3; }
    void Foo() { std::cout << 1; }
    void Foo() const { std::cout << 2;}
}

int main() {
    S s;
    const S const_s;

    s.Bar(); s.Foo(); // 3 1
    const_s.Bar(); const_s.Foo(); // 3 2

    const_s.Test(); // CE
}
```
---

Иногда мы хотим некоторые поля менять в константных методах. Для этого их нужно пометить mutable:

```c++
struct S {
    int a = 0;
    mutable int b = 10;
    void Foo const() {
        a += 1; // CE
        b += 1; // OK
    }
}
```

---

Константность на поля класса навешивается "справа":

```c++
struct S {
  char* /* const */ arr; // константный указатель
  int& ref;

  void Foo() const {
    *arr = 20; // ok
    ref += 1; // ok
  }

}
```
---

### 3.9.14 Статические поля и методы

Иногда мы хотим иметь в классе поле которое едино для всех объектов этого класса:

```c++
struct S {
  static int x;
};

int main() {
  std::cout << S::x;
}
```

То есть это что-то вроде глобальной переменной с ограниченной областью видимости

---

С методами такое тоже работает:

```c++
struct S {
  static void Foo() {
    ++a; // CE
    ++x; // ok
  }

  int a;
  static int x;
};

int main() {
  S::Foo();
}
```

***Note*** Если метод/поле приватные, то с ними взаимодействовать сможет только ваш класс (или его друзья)

---
<!-- header: ""-->

# 4. Перегрузка операторов

1. Какие операторы можно перегружать
2. Оператор присваивания. Правило трех
3. Арифметические операторы
4. Операторы сравнения
5. Инкремент и декремент
6. Круглые скобки и понятие функтора
7. Квадратные скобки
8. Операторы &&, || и ,
9. Операторы * и ->
10. Перегрузка операторов ввода/вывода в поток
---

<!-- header: "4. Перегрузка операторов"-->

## 4.1. Какие операторы можно перегружать

Проще перечислить какие операторы нельзя перегружать:

* *_cast
* .
* ::
* ?:
* new/delete (тут спорный момент, пока его упустим)

---

Несколько важных правил:

* Перегружать поведение операторов для базовых типов нельзя. То есть можно перегрузить поведение оператора только если одним из операндов является кастомный тип
* При перегрузке операторов нельзя менять их арность. То есть если оператор был бинарным, его нельзя сделать тернарным или унарным
* Нельзя заводить новые операторы. То есть можно только перегрузить поведение для существующего в плюсах оператора

---

## 4.2. Оператор присваивания. Правило трех

***Def*** Оператор присваивания позволяет скопировать существующий объект в другой существующий объект

```c++
Vector v1(10);
Vector v2(3);
v1 = v2;
```

Оператор присваивания генерируется по умолчанию: просто копирует каждое поле. Нас это поведение конечно же не устраивает

---

<!-- header: "4.2. Оператор присваивания. Правило трех"-->

Напишем оператор присваивания для вектора:

```c++
class Vector {
public:
  ... operator=(const Vector& v) {

  }
private:
  int* arr_ = nullptr;
  size_t size_ = 0;
};
```

Какой возвращаемый тип?

---

```c++
class Vector {
public:
  Vector& operator=(const Vector& v) {
    delete[] arr_;
    size_ = v.size_;
    arr_ = new int[size_];
    memcpy(arr_, other.arr_, size_);

    return *this;
  }
private:
  int* arr_ = nullptr;
  size_t size_ = 0;
};
```

Проблема: что делать если присвоили себя?

---

Первое решение: проверка на адрес

```c++
Vector& operator=(const Vector& v) {
  if (&v == *this) {
    return;
  }

  delete[] arr_;
  size_ = v.size_;
  arr_ = new int[size_];
  memcpy(arr_, other.arr_, size_);

  return *this;
}
```

---
Второе решение: ***Copy and swap***

```c++
Vector& operator=(const Vector& v) {
  Vector copy = v;
  swap(copy); // А вот его нужно реализовать

  return *this;
}
```

---

***Def*** Правило трех: если класс такой, что вы определили нетривиальный конструктор, деструктор или оператор присваивания то скорее всего вам нужно реализовать все их. Правило трех это исключительно словесное правило, компилятор ему не следует

---

<!-- header: "4. Перегрузка операторов"-->

## 4.3. Арифметические операторы


Для своего типа можно перегрузить поведение любого арифметического оператора.

Есть два способа перегрузить бинарный оператор: внутри класса и снаружи. Посмотрим на оба из них

---
<!-- header: "4.3. Арифметические операторы"-->

### Внутри класса

Тогда наш оператор должен принимать ОДИН объект нашего класса (потому что левый операнд это сам наш объект)

```c++
struct Int {
  Int(int value): value(value) {}
  Int operator+(const Int& other) {
    return Int(value + other.value);
  }
  int value = 0;
};

int main() {
  Int a(10);
  Int b(20);
  Int c = a + b; // OK
  10 + a; // CE
}
```
---

CE возникает так как левый операнд не может быть неявно приведен к нашему классу. А в случае арифмитических операторов такое хочется делать. Поэтому второй способ более приоритетный для арифмитических операторов

---

### Снаружи класса

```c++
struct Int {
  Int(int value): value(value) {}
  int value = 0;
};

Int operator+(const Int& lhs, const Int& rhs) {
  return Int(lhs.value + rhs.value);
}
```

Следующая проблема: а что если value это приватное поле? Писать friend на каждый оператор? ***НЕТ***

---

Выход: геттеры

```c++
class Int {
public:
  Int(int value): value_(value) {}

  int GetValue() const {
    return value_;
  }
private:
  int value_;
}

Int operator+(const Int& lhs, const Int& rhs) {
  return Int(lhs.GetValue() + rhs.GetValue());
}
```

---

Следующий важный тип арифметических операторов это операторы формата +=:

```c++
class Int {
public:
  Int(int value): value_(value) {}

  int GetValue() const {
    return value_;
  }

  Int& operator+=(const Int& other) {
    value_ += other.GetValue();

    return *this;
  }
private:
  int value_;
}
```

---

Еще существуют унарные + и -

```c++
Int& Int::operator+() {
  return *this;
}

Int& Int::operator-() {
  value_ *= -1;
  return *this;
}
```

---

Важные правила перегрузки арифметических операторов:

* бинарные перегружаем вне класса ради неявного каста
* бинарные выражаем через версию с присваиванием (+ через += и тд)

---

<!-- header: "4. Перегрузка операторов"-->

## 4.4 Операторы сравнения

Для начала перегрузим оператор <:

```c++
bool operator<(const Int& lhs, const Int& rhs) {
  return lhs.GetValue() < rhs.GetValue();
}
```

Его нужно перегружать снаружи по тем же причинам что и +.

Почему же мы начали перегрузку с <?

---

Потому что через него можно выразить все!

Например >:

```c++
bool operator>(const Int& lhs, const Int& rhs) {
  return rhs < lhs;
}
```

А с == как быть?

---

```c++
bool operator==(const Int& lhs, const Int& rhs) {
  return !(lhs < rhs) && !(rhs < lhs);
}
```

С остальными так же :)

***Note*** == на самом деле лучше реализовывать честно, чтобы не делать два вызова вместо одного

---

### spaceship operator (since C++20)

Всем надоело писать < и выражать через него все остальное. Поэтому появился оператор <=>.  Вот как с ним работать:

```c++
class Int {
public:
  Int(int value): value_(value) {}

  int GetValue() const {
    return value_;
  }

  auto operator<=>(const Int&) const = default;
private:
  int value_;
}
```

---

Более того начиная с C++20 == может быть сгенерирован по умолчанию:

```c++
class Int {
public:
  Int(int value): value_(value) {}

  int GetValue() const {
    return value_;
  }

  auto operator==(const Int&) const = default;
private:
  int value_;
}
```

[Пример с cppref](https://en.cppreference.com/w/cpp/language/default_comparisons)

---

## 4.5. Инкремент и декремент

Конечно же нужно еще перегрузить префиксный и постфиксный инкременты:

```c++
Int& Int::operator++() {
  *this += 1;
  return *this;
}
```

Но как перегрузить постфиксный если семантика совпадает?

---

Используем костыль!

```c++
Int& Int::operator++() {
  *this += 1;
  return *this;
}

Int Int::operator++(int) { // фейковый параметр
  Int copy = *this;
  *this += 1;
  return copy;
}
```
---

## 4.6. Круглые скобки и понятие функтора

Для своего класса можно перегрузить оператор ()

***Def*** функтор - объект который может вести себя как функция (имеет круглые скобки)

Такие классы полезны, когда, например, мы хотим передать функцию сравнения в сортировку

---

```c++
struct IntCompare {
  bool operator()(int lhs, int rhs) const {
    return lhs % 5 < rhs % 5;
  }
};

int main() {
  std::vector<int> v{21, 22, 33, 47};
  std::sort(v.begin(), v.end(), IntCompare());
  // 21 22 47 33
}
```

***Note*** обычно оператор() делают константным

---

## 4.7. Квадратные скобки

Их тоже можно перегружать:

```c++
class Vector {
public:
  int& operator[](size_t index) {
    return arr_[index];
  }
private:
  int* arr_ = nullptr;
  size_t size_ = 0;
};
```
* Что делать с константной версией?
* А если хочется больше аргументов?
* Проверка индекса?

---

### Что делать с константной версией?

Просто написать ее :)

```c++
class Vector {
public:
  int& operator[](size_t index) { return arr_[index]; }
  const int& operator[](size_t index) const {return arr_[index]; }
private:
  int* arr_ = nullptr;
  size_t size_ = 0;
};
```

---

### А если хочется больше аргументов?

Начиная с C++23 [] могут принимать любое количество аргументов:

```c++
class Vector {
public:
  int& operator[](size_t x, size_t y) { return arr_[x][y]; }
private:
  int** arr_ = nullptr;
  size_t size_ = 0;
};

int main() {
  Vector v;
  v[1, 2];
}
```

---

### Проверка индекса?

В [] индекс принято не проверять. Для доступа с проверкой пишут метод at (все ради скорости)

![w:1200 h:400](https://a.d-cd.net/NuVTZ8XZ8pUjJgedr5700FJ_MGM-960.jpg)

---

### А всегда ли надо возвращать type&?

* Краткий ответ: нет
* Длинный ответ: vector<bool>

---

## 4.8. Операторы &&, || и ,

* Их тоже можно перегружать....
* При перегрузке операторов &&, || теряется свойство ленивого вычисления

---

## 4.9 Операторы * и ->

Допустим мы реализуем объект, который похож на указатель. Тогда:

* С оператором * все очевидно: он должен возвращать ссылку на объект, который лежит под указателем. Он кстати должен быть константным
* Со стрелочкой интересней. Правило звучит так: стрелочка должна возвращать то, к чему можно применить стрелочку пока это не дойдет до базового типа.

---

Реализуем стрелочку для класса, который хранит указатель на объект типа T

```c++
struct T {};

struct TPointer {
  T* ptr;

  T* operator->() const {
    return ptr;
  }
}
```
---

## 4.10. Перегрузка операторов ввода/вывода в поток

Тут все достаточно просто:

```c++
struct S {
  int a = 0;
};
std::ostream& operator<<(std::ostream& os, const S& s) {
  os << s.a;
  return os;
}
std::istream& operator>>(std::istream& is, S& s) {
  is >> s.a;
  return is;
}
```

---
Спасибо за внимание!

![img](https://cataas.com/cat/gif)