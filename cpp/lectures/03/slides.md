---
marp: true
theme: gaia
footer: 'Программирование на языке C++. Гагаринов Даниил. ВШПИ МФТИ 2023'
paginate: true

---
<style>
{
    font-size: 30px
}
</style>

# Лекция 3

---

<!-- header: "2. Модификаторы типов. Указатели. Функции. Ссылки и константы. Приведение типов."-->

## 2.6 Ссылки и константы. Приведение типов.

1. Ссылки
2. Константы
3. Приведение типов и касты

---

<!-- header: "2.6 Ссылки и константы. Приведение типов."-->

## 2.6.1 Ссылки

***Note*** Ссылки это концепция, которая появилась в языке C++ (в C их нет)

Постановка проблемы:

1. Хотим создавать псевдонимы (синонимы) для переменных:

```c++
int first = 0;
int second = a;
```

То есть хотим чтобы second интепретировалась бы как новое имя для переменной first, а не как новая переменная

---

<!-- header: "2.6.1 Ссылки"-->

2. Хотим легковесный способ передачи аргументов (без указателей). Допустим мы хотим написать функцию, которая принимала бы вектора и меняла его, если мы напишем так:

```c++
void f(std::vector<int> v) {...}
```

то при каждом вызове функции f вектор будет копироваться и изменять мы будем копию

***Note*** Эту проблему конечно можно решить с помощью указателей, то есть передавать адрес вектора. Это не очень удобно, потому что каждый раз этот адрес нужно разименовывать.

---
Объявим ссылку:

```c++
int a = 1;
int& b = a;
```

то есть добавление знака & к типу T означает что мы хотим создать ссылку на переменную типа T.

Теперь b это новое название для переменной a.
То есть если мы поменяем a, то поменяется и b (и наоборот).

Для параметров функции это работает аналогично.

***Note*** ссылка привязывается на все время своего существование. То есть если у нас есть ссылка second которая указывает на переменную first, то эту ссылку нельзя перепривязать ни к чему другому.

---
Важное:


* С текущим уровнем знаний мы никак не сможем отличить ссылку от переменной на которую она ссылается. То есть любые операции с ссылкой будут давать тот же результат что и с переменной (даже адрес будет совпадать).
* Нельзя объявить ссылку без инициализации, ведь она должна быть к чему-то привязана
* Ссылку можно проинициализировать только lvalue, то есть нельзя написать что-то такое int& a = 10

---

* Нельзя перегружать по ссылке:

```c++
void f(int& c) {}
void f(int c) {}

int main() {
  int a;
  int& b = a;
  f(a);
}
```

Будет CE так как нельзя отличить ссылку от не ссылки

---

Что еще нельзя:

* Нельзя объявить указатель на ссылку: ```int&* a = &c;``` = CE
* Нельзя объявить массив ссылок
* Нельзя объявить ссылку на ссылку.

---

## Swap upgraded!

Теперь мы можем написать нормальный swap (до move-семантики)

Идеи?

---

## Swap upgraged!

```c++
void swap(int& a, int& b) {
  int tmp = a;
  a = b;
  b = tmp;
}
```
---
## Возвращение ссылок из функций

```c++
int& f(int& x) {
  ++x;
  return x;
}

int main() {
  int a = 10;
  f(a) = 20;
}
```

Такой код работает

---
## Возвращение ссылок из функций

```c++
int& f() {
  int x = 10;
  return x;
}

int main() {
  int& a = f();
  a = 10;
}
```

Это UB потому что это битая ссылка (dangling reference) (вернули ссылку на объект который уже не существует после выхода из функции)

---

Уничтожение ссылки не ведет к уничтожению объекта:

```c++
int main() {
  int a = 10;
  {
    int& b = a;
  }
  a = 5; // OK
}
```
---
<!-- header: "2.6 Ссылки и константы. Приведение типов."-->

## 2.6.2 Константы

Иногда нам хочется явно указать что какую-то переменную нельзя менять:

```c++
int main() {
  const int a = 5;
}
```

***Def*** То есть const T это такой тип, который ведет себя почти как T, но поддерживает меньше операций над собой

---

<!-- header: "2.6.2 Константы"-->

### Навешивание констант на указатели

Константу можно "навесить" на уже известные нам указатели:

```c++
int main() {
  int a;
  const int* ptr = &a;
}
```

Сам указатель менять можно, а вот то что под ним нельзя

---

Можно завести константный указатель:

```c++
int main() {
  int a;
  int* const ptr = &a;
}
```

Тогда сам указатель менять нельзя, а то что под ним можно

---

Можно создать константный указатель на константу:

```c++
int main() {
  int a;
  const int* const ptr = &a;
}
```

---

Все примеры вместе:

```c++
int main() {
  int a = 5;

  const int* p = &a;
  ++p; // OK
  ++*p; // CE

  int* const pp = &a;
  ++pp; // CE
  ++*pp; // OK

  const int* const ppp = pp; // OK (cast from int* to const int*)
  ++ppp; // CE
  ++*ppp; // CE

  int* const q = ppp; // CE (запрещенный каст)
  const int* qq = ppp; // OK, copy
}
```

---

### Навешивание констант на ссылки

Можно завести константную ссылку:

```c++
int main() {
  int a = 5;
  const int& ref = a;
}
```

Эта ссылка предоставляет только доступ на чтение. Присвоить обычной ссылке константную нельзя:

```c++
int main() {
  int a = 5;
  const int& ref = a;
  int& b = ref; // CE
}
```

---

### 4 способа передачи в функцию значение:

* По значению (будет копия)
* По константному значению (бессмысленно, так никто не пишет)
* По ссылке (можем менять исходный объект)
* По константной ссылке (без копии, но объект менять не можем)

***Note*** Можно делать перегрузку по константной и не константной ссылкам.

---

### Продление жизни

Константной ссылке можно присваивать временные объекты:

```c++
int main() {
  const int& a = 5;
}
```

---
<!-- header: "2.6 Ссылки и константы. Приведение типов."-->

## 2.6.3 Приведение типов и касты

В языке C существовал только один способ каста:

```c++
int main() {
  int a = 5;
  double d = (double)a;
}
```

Это C-style каст.

***Так кастить не нужно***

---

<!-- header: "2.6.3 Приведение типов и касты"-->

### static_cast

```c++
int main() {
  int a = 5;
  double d = static_cast<double>(a); // тут создалась новая сущность
}
```

***Def*** static_cast использует преобразование известное компилятору. Их много, например bool в int, const char* в std::string и тд.

***Note*** static он потому что проверяет возможность конвертации на этапе компиляции

---

### reinterpret_cast

```c++
int a = 0;
double* b = reinterpret_cast<double*>(&a);
```

***Def*** reinterpret_cast интепретирует байты памяти одного типа как байты памяти другого типа. reinterpret_cast умеет приводить только указатели и ссылки, потому что он не создает новых сущностей.

---

### const_cast

```c++
void f(int &) {} // 1
void f(const int&) {} // 2

int main() {
  int a = 10;
  f(a); // 1
  f(const_cast<const int&>(a)); // 2
}
```

***Def*** const_cast нужен для навешивания и снятия константности

---

***Note*** При снятии константы это будет адекватно работать только если тип изначально был не константой

```c++
int main() {
  int c = 5;
  const int& a = c;
  int& x = const_cast<int&>(a);
  ++x; // OK

  const int d = 10;
  int& dd = const_cast<int&>(d);
  ++dd; // UB
}
```

---

### c-style каст

Этот каст по очереди применяет все касты выше (в комбинациях с const_cast)

Именно поэтому им нельзя пользоваться :)

---
<!-- header: ""-->

# 3. Основы ООП

1. Основные термины
2. Структуры в C
3. Классы и структуры в C++. Основной синтаксис
4. Поля и методы. Инициализация по умолчанию. Определение методов вне класса.
5. Операторы ".", "->" и ключевое слово this
6. Class scope
7. Внутренние классы
8. Модификаторы доступа
9. Конструкторы и деструкторы. Ключевое слово explicit. Делигирующие конструкторы


---

<!-- header: "3. Основы ООП"-->

## 3.1 Основные термины

### Абстракция

Абстрагирование означает выделение значимой информации и исключение из рассмотрения незначимой. В ООП рассматривают лишь абстракцию данных (нередко называя её просто «абстракцией»), подразумевая набор наиболее значимых характеристик объекта, доступных остальной программе.

---

<!-- header: "3.1 Основные термины"-->

### Инкапсуляция

Свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе.

***Note*** В C++ под инкапсуляцией так же понимается сокрытие данных, но вообще говоря это необязательное условие

---

### Наследование

Наследование — свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствованной функциональностью.

---

### Полиморфизм

Полиморфизм подтипов (в ООП называемый просто «полиморфизмом») — свойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

---

<!-- header: "3. Основы ООП"-->

## 3.2 Структуры в C

```c++
struct TestStruct {
  int a;
  int b;
  int c;
};

int main() {
  struct TestStruct s;
  s.a = 10;
  s.b = 20;
  s.c = 30;
}
```

***Note*** ничего кроме упаковки данных в одну сущность не умеют

---

## 3.3. Классы и структуры в C++. Основной синтаксис

***Note*** До момента, о котором будет сказано, class и struct это одно и тоже

***Def*** Класс - кастомный тип данных, состоящий из набора "полей" и методов для взаимодействия с ними

```c++
class MyAwesomeClass {
    ...
};

int main() {
  MyAwesomeClass c;
  sizof(c); // 1
}
```

---

## 3.4 Поля и методы. Инициализация по умолчанию. Определение методов вне класса.

***Def*** Поля - перечисление данных, которые хранит в себе объект
***Def*** Методы класса - перечисление функций, которые можно делать над объектом данного класса

```c++
struct Student {
    std::string name;
    size_t grade;

    void Print() {
        std::cout << name << " " << grade << std::endl;
    }
};
```
***Note*** Из методов класса нам доступны его поля

---

<!-- header: "3.4 Поля и методы. Инициализация по умолчанию. Определение методов вне класса"-->

```c++
int main() {
    Student student;
    student.Print();
}
```

* Получили какой-то мусор в поле grade
* Получили пустую строку в поле name

---

### Указание значений по умолчанию


```c++
struct Student {
    std::string name = "Test";
    size_t grade = 10;

    void Print() {
        std::cout << name << " " << grade << std::endl;
    }
};
```

---

### Определение методов вне класса

```c++
struct Student {
    std::string name;
    size_t grade;

    void Print(); // Объявили
};

void Student::Print() {
  std::cout << name << " " << grade << std::endl; // определили
}
```

---

<!-- header: "3. Основы ООП"-->

## 3.5 Операторы ".", "->" и ключевое слово this

```c++
int main() {
    Student student;
    student.Print();
    Student* ptr;
    ptr->Print();
}
```

* Оператор "." нужен для обращения к полям и методам объекта
* Оператор "->" нужен для обращения к полям и методам указателя

---

### Ключевое слово this

Внутри методов класса определен указатель this = указатель на текущий объект:

```c++
struct Student {
    std::string name = "Test";
    size_t grade = 10;

    void Print() {
        std::cout << this->name << " " << this->grade << std::endl;
    }
};
```

***Note*** так писать не надо!


---

## 3.6 Class scope

***Def*** Место в коде от фигурной скобки открывающей класс до ; называется Class scope. В этом скоупе можно делать только объявления (и определения). То есть здесь нельзя писать выражения и управляющие конструкции.


---

## 3.7 Внутренние классы

В class-scope можно объявлять новые структуры/классы и юзинги:

```c++
struct Student {
  struct Test {
    int a;
    int b;
  };
  using Time = size_t;
};
```

***Note*** внутри функций тоже можно объявлять классы и структуры

---

## 3.8 Модификаторы доступа

```c++
class C {
 public: // после открытия секции все до конца класса/объявления новой секции будет публичным
  int a;
 private:
  int b;
 protected:
  int c;
 public: // Можно переоткрывать секцию бесконечное количество раз
  void Foo();
}

int main() {
  C c;
  c.a; // OK
  c.b; // CE, так как b приватный член класса C
  c.c; // CE, так как c протектед член класса C
  c.Foo(); // OK
}
```

---

* Разницу между protected и private мы поймем когда будем проходить наследование
* Первое отличия класса от структуры: в структурах модификатор доступа по умолчанию - public (в классе private)
* Проверка доступа происходит после выбора перегрузки

---

## 3.9 Конструкторы и деструкторы. Ключевое слово explicit. Делигирующие конструкторы

1. Понятие конструктора. Пример
2. Списки инициализации
3. Конструктор по умолчанию
4. Перегрузка конструкторов
5. Понятие деструктора. Пример
6. Порядок вызова конструкторов и деструкторов

---
<!-- header: "3.9 Конструкторы и деструкторы. Ключевое слово explicit. Делигирующие конструкторы"-->

### 3.9.1. Понятие конструктора. Пример

***Def*** конструктор это специальный метод класса, который описывает как создать объект от каких-то параметров

```c++
class Student {
 public:
  Student(const std::string& name, size_t grade) {
    name_ = name; // 1
    grade_ = grade;
  }
 private:
  std::string name_;
  size_t grade_;
}
```
***Note*** В строке 1 поля name_ и grade_ уже проинициализированы значениями по умолчанию

---

### 3.9.2. Списки инициализации

```c++
class Student {
 public:
  Student(const std::string& name, size_t grade): name_(name), grade_(grade) {}
 private:
  std::string name_;
  size_t grade_;
}
```

***Note*** Конструкторы полей будут вызываться в том порядке, в котором они перечислены в теле класса вне зависимости от порядка перечисления в списке инициализации

---

Иногда без списков инициализации не обойтись:

```c++
int x = 0;
struct S {
  S() {
    ref = x; // CE
  }

  int& ref;
}
```
Исправим:

```c++
int x = 0;
struct S {
  S(): ref(x) {}

  int& ref;
}
```
---
### 3.9.3. Конструктор по умолчанию

***Def*** Конструктор по умолчанию это конструктор без аргументов.

```c++
class Student {
 public:
  Student() {
    std::cout << "default construct";
  }

  Student(const std::string& name, size_t grade): name_(name), grade_(grade) {}
 private:
  std::string name_;
  size_t grade_;
};

int main() {
  Student s;
}
```

---

***Note*** Компилятор сам генерирует конструктор по умолчанию (конструктор с пустым телом). При этом если существует хотя бы один написанный вами конструктор компилятор перестает генерировать конструктор по умолчанию.

---

### 3.9.4. Перегрузка конструкторов

Перегрузка конструкторов работает по тем же правилам что и перегрузка функций

---

### 3.9.5. Понятие деструктора. Пример

***Def*** Деструктор это специальный метод который вызывается при уничтожении объекта

```c++
struct S {
  ~S() {
    std::cout << "destroy";
  }
};

int main() {
  S s;
} // вызовется после выхода из области видимости
```

***Note*** Деструктор генерируется компилятором всегда (пустой)

---

Деструктор - необходимая вещь:

```c++
class Vector {
 public:
  Vector(size_t size, int value = 0): size_(size) {
    arr_ = new int[size_];
    for (int i = 0; i < size; ++i) {
      arr_[i] = value;
    }
  }

  ~Vector() { // деструктор
    delete[] arr_;
  }
 private:
  int* arr_ = nullptr;
  size_t size_ = 0;
}
```

---

***Note*** Деструктор не может принимать никаких аргументов

***Note*** Хоть деструктор и можно вызвать руками, делать этого не нужно! (вызов двух деструкторов у объекта это UB)

---

### 3.9.6. Порядок вызова конструкторов и деструкторов

При создании:

1. Сначала вызываются конструкторы для каждого поля (в порядке в котором поля перечислены в классе)
2. Потом вызывается конструктор вашего класса

При уничтожении:

1. Сначала вызывается деструктор класса
2. Потом вызывается деструктор для каждого поля (в обратном порядке)

---

```c++
#include <iostream>

struct S {
  S() { std::cout << "S" << std::endl; }
  ~S() { std::cout << "~S" << std::endl; }
};

struct SS {
  SS() { std::cout << "SS" << std::endl; }
  ~SS() { std::cout << "~SS" << std::endl; }
};

struct Test {
  Test(int a): a{a} { std::cout << "Test " << a << std::endl; }
  ~Test() { std::cout << "~Test " << a << std::endl; }

  S s;
  SS ss;
  int a;
};

int main() {
  Test t1(1);
  Test t2(2);
} // Вывод: S SS Test 1 S SS Test 2 \~Test 2 \~SS \~S \~Test 1 \~SS \~S
```

---

Спасибо за внимание!

![img](https://cataas.com/cat/gif)